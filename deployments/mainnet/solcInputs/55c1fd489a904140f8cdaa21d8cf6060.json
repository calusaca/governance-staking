{
  "language": "Solidity",
  "sources": {
    "src/Delegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IGovernanceToken.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\n\n/**\n * @title Delegator Contract\n * @author Cryptex.Finance\n * @notice Contract in charge of handling delegations.\n */\n\ncontract Delegator is Ownable {\n   /* ========== STATE VARIABLES ========== */\n\n   /// @notice Address of the staking governance token\n   address public immutable token;\n\n   /// @notice Tracks the amount of staked tokens per user\n   mapping(address => uint256) public stakerBalance;\n\n   /* ========== CONSTRUCTOR ========== */\n\n   /**\n    * @notice Constructor\n    * @param delegatee_ address\n    * @param token_ address\n    * @dev when created delegates all it's power to delegatee_ and can't be changed later\n    * @dev sets delegator factory as owner\n    */\n   constructor(address delegatee_, address token_) {\n      require(\n         delegatee_ != address(0) && token_ != address(0),\n         \"Address can't be 0\"\n      );\n      require(IGovernanceToken(token_).decimals() == 18, \"Decimals must be 18\");\n      token = token_;\n      IGovernanceToken(token_).delegate(delegatee_);\n   }\n\n   /* ========== MUTATIVE FUNCTIONS ========== */\n\n   /**\n    * @notice Increases the balance of the staker\n    * @param staker_ caller of the stake function\n    * @param amount_ uint to be staked and delegated\n    * @dev Only delegatorFactory can call it\n    * @dev after the balance is updated the amount is transferred from the user to this contract\n    */\n   function stake(address staker_, uint256 amount_) external onlyOwner {\n      stakerBalance[staker_] += amount_;\n   }\n\n   /**\n    * @notice Decreases the balance of the staker\n    * @param staker_ caller of the stake function\n    * @param amount_ uint to be withdrawn and undelegated\n    * @dev Only delegatorFactory can call it\n    * @dev after the balance is updated the amount is transferred back to the user from this contract\n    */\n   function removeStake(address staker_, uint256 amount_) external onlyOwner {\n      stakerBalance[staker_] -= amount_;\n      require(\n         IGovernanceToken(token).transfer(staker_, amount_),\n         \"Transfer failed\"\n      );\n   }\n\n   /* ========== VIEWS ========== */\n\n   /// @notice returns the delegatee of this contract\n   function delegatee() external returns (address) {\n      return IGovernanceToken(token).delegates(address(this));\n   }\n}\n"
    },
    "src/interfaces/IGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IGovernanceToken {\n   function delegate(address delegatee) external;\n\n   function delegates(address delegator) external returns (address);\n\n   function transfer(address dst, uint256 rawAmount) external returns (bool);\n\n   function transferFrom(\n      address src,\n      address dst,\n      uint256 rawAmount\n   ) external returns (bool);\n\n   function balanceOf(address src) external returns (uint256);\n\n   function decimals() external returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/tests/DelegatorFactory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../lib/ds-test/src/test.sol\";\nimport \"./hevm.sol\";\n\nimport \"../Delegator.sol\";\nimport \"../DelegatorFactory.sol\";\nimport \"../mocks/GovernanceToken.sol\";\n\ncontract User {\n   function approveAmount(\n      GovernanceToken t,\n      DelegatorFactory d,\n      uint256 a\n   ) public {\n      t.approve(address(d), a);\n   }\n\n   function doCreateDelegator(DelegatorFactory d, address delegatee) public {\n      d.createDelegator(delegatee);\n   }\n\n   function doDelegate(\n      DelegatorFactory d,\n      address delegator,\n      uint256 amount\n   ) public {\n      d.stake(delegator, amount);\n   }\n\n   function doRemoveDelegate(\n      DelegatorFactory d,\n      address delegator,\n      uint256 amount\n   ) public {\n      d.withdraw(delegator, amount);\n   }\n\n   function doUpdateWaitTime(DelegatorFactory d, uint256 waitTime) public {\n      d.updateWaitTime(waitTime);\n   }\n\n   function doUpdateRewards(DelegatorFactory d, uint256 reward) public {\n      d.notifyRewardAmount(reward);\n   }\n\n   function doSetRewardsDuration(DelegatorFactory d, uint256 time) public {\n      d.setRewardsDuration(time);\n   }\n\n   function doClaimRewards(DelegatorFactory d) public {\n      d.getReward();\n   }\n}\n\ncontract FakeDelegator {\n   function stake(address staker_, uint256 amount_) public {\n      // do nothing and keep funds\n   }\n\n   function removeStake(address staker_, uint256 amount_) public {\n      // do nothing and keep funds\n   }\n}\n\ncontract FakeToken {\n   function decimals() public pure returns (uint8) {\n      return 10;\n   }\n}\n\ncontract DelegatorFactoryTest is DSTest {\n   DelegatorFactory delegatorFactory;\n   GovernanceToken ctx;\n   User user1;\n   uint256 waitTime = 1 weeks;\n   Hevm public hevm = Hevm(HEVM_ADDRESS);\n\n   function setUp() public {\n      ctx = new GovernanceToken(address(this), address(this), block.timestamp);\n      delegatorFactory = new DelegatorFactory(\n         address(ctx),\n         address(ctx),\n         waitTime,\n         address(this)\n      );\n      user1 = new User();\n   }\n\n   function test_parameters() public {\n      assertEq(delegatorFactory.owner(), address(this));\n      assertEq(delegatorFactory.stakingToken(), address(ctx));\n      assertEq(delegatorFactory.waitTime(), waitTime);\n      assertEq(delegatorFactory.rewardsToken(), address(ctx));\n      assertEq(delegatorFactory.rewardsDuration(), 186 days);\n   }\n\n   function testFail_invalidStakingToken() public {\n      new DelegatorFactory(address(0x0), address(ctx), waitTime, address(this));\n   }\n\n   function testFail_invalidRewardToken() public {\n      new DelegatorFactory(address(ctx), address(0x0), waitTime, address(this));\n   }\n\n   function testFail_invalidStakingTokenDecimals() public {\n      FakeToken f = new FakeToken();\n      new DelegatorFactory(address(f), address(ctx), waitTime, address(this));\n   }\n\n   function testFail_invalidRewardTokenDecimals() public {\n      FakeToken f = new FakeToken();\n      new DelegatorFactory(address(ctx), address(f), waitTime, address(this));\n   }\n\n   function testFail_invalidTimelock() public {\n      new DelegatorFactory(address(ctx), address(ctx), waitTime, address(0x0));\n   }\n\n   function test_createDelegator(address delegatee) public {\n      if (delegatee == address(0)) return;\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n      Delegator d = Delegator(delegator);\n      assertEq(d.delegatee(), delegatee);\n      assertEq(delegatorFactory.delegateeToDelegator(delegatee), address(d));\n      assertEq(delegatorFactory.delegatorToDelegatee(address(d)), delegatee);\n      assertEq(d.owner(), address(delegatorFactory));\n   }\n\n   function testFail_invalidCreateDelegator() public {\n      delegatorFactory.createDelegator(address(0));\n   }\n\n   function testFail_createDelegator(address delegatee) public {\n      delegatorFactory.createDelegator(delegatee);\n      delegatorFactory.createDelegator(delegatee);\n   }\n\n   function test_delegate() public {\n      address delegatee = address(0x1);\n      uint256 amount = 1 ether;\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      uint256 prevBalDelegator = ctx.balanceOf(delegator);\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n      uint256 prevBalDelegatee = ctx.balanceOf(delegatee);\n      assertEq(prevBalDelegatee, 0);\n      assertEq(prevBalDelegator, 0);\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      uint256 balDelegatee = ctx.balanceOf(delegatee);\n      uint256 balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker - amount);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), amount);\n      assertEq(\n         delegatorFactory.stakerWaitTime(address(this), delegator),\n         waitTime\n      );\n      assertEq(amount, delegatorFactory.balanceOf(address(this)));\n      assertEq(amount, delegatorFactory.totalSupply());\n   }\n\n   function test_delegateFuzz(address delegatee, uint256 amount) public {\n      if (amount > ctx.totalSupply()) return;\n      if (amount == 0) return;\n      if (delegatee == address(0)) return;\n\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      uint256 prevBalDelegator = ctx.balanceOf(delegator);\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n      uint256 prevBalDelegatee = ctx.balanceOf(delegatee);\n      assertEq(prevBalDelegatee, 0);\n      assertEq(prevBalDelegator, 0);\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      uint256 balDelegatee = ctx.balanceOf(delegatee);\n      uint256 balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker - amount);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), amount);\n      assertEq(\n         delegatorFactory.stakerWaitTime(address(this), delegator),\n         waitTime\n      );\n      assertEq(amount, delegatorFactory.balanceOf(address(this)));\n      assertEq(amount, delegatorFactory.totalSupply());\n   }\n\n   function testFail_invalidDelegator() public {\n      uint256 amount = 1 ether;\n      ctx.transfer(address(user1), amount);\n      FakeDelegator faker = new FakeDelegator();\n      user1.approveAmount(ctx, delegatorFactory, amount);\n      user1.doDelegate(delegatorFactory, address(faker), amount);\n   }\n\n   function testFail_invalidAmount() public {\n      address delegatee = address(0x1);\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n      delegatorFactory.stake(delegator, 0);\n   }\n\n   function test_multipleDelegators(uint256 amount, uint256 amount2) public {\n      if (amount > ctx.totalSupply() / 2 || amount2 > ctx.totalSupply() / 2)\n         return;\n      if (amount == 0 || amount2 == 0) return;\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n      address delegatee1 = address(0x1);\n      address delegatee2 = address(0x2);\n      delegatorFactory.createDelegator(delegatee1);\n      delegatorFactory.createDelegator(delegatee2);\n      address delegator1 = delegatorFactory.delegateeToDelegator(delegatee1);\n      address delegator2 = delegatorFactory.delegateeToDelegator(delegatee2);\n      ctx.approve(address(delegatorFactory), amount + amount2);\n      delegatorFactory.stake(delegator1, amount);\n      hevm.warp(waitTime);\n      delegatorFactory.stake(delegator2, amount2);\n\n      assertEq(\n         ctx.balanceOf(address(this)),\n         prevBalStaker - (amount + amount2)\n      );\n      assertEq(ctx.balanceOf(delegator1), amount);\n      assertEq(ctx.balanceOf(delegator2), amount2);\n      assertEq(ctx.getCurrentVotes(delegatee1), amount);\n      assertEq(ctx.getCurrentVotes(delegatee2), amount2);\n      assertEq(\n         delegatorFactory.stakerWaitTime(address(this), delegator1),\n         waitTime\n      );\n      assertEq(\n         delegatorFactory.stakerWaitTime(address(this), delegator2),\n         2 weeks\n      );\n      assertEq(amount + amount2, delegatorFactory.balanceOf(address(this)));\n      assertEq(amount + amount2, delegatorFactory.totalSupply());\n   }\n\n   function test_unDelegate() public {\n      address delegatee = address(0x1);\n      uint256 amount = 1 ether;\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, amount);\n      uint256 balDelegatee = ctx.balanceOf(delegatee);\n      uint256 balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, 0);\n      assertEq(ctx.getCurrentVotes(delegatee), 0);\n      assertEq(0, delegatorFactory.balanceOf(address(this)));\n      assertEq(0, delegatorFactory.totalSupply());\n   }\n\n   function test_unDelegateFuzz(address delegatee, uint256 amount) public {\n      if (amount > ctx.totalSupply()) return;\n      if (amount == 0) return;\n      if (delegatee == address(0)) return;\n\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, amount);\n      uint256 balDelegatee = ctx.balanceOf(delegatee);\n      uint256 balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, 0);\n      assertEq(ctx.getCurrentVotes(delegatee), 0);\n      assertEq(0, delegatorFactory.balanceOf(address(this)));\n      assertEq(0, delegatorFactory.totalSupply());\n   }\n\n   function testFail_unDelegateNoWait(address delegatee, uint256 amount)\n      public\n   {\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, (amount));\n   }\n\n   function test_unDelegateSpecific(\n      address delegatee,\n      uint256 amount,\n      uint256 amount2\n   ) public {\n      if (amount > ctx.totalSupply() / 2 || amount2 > ctx.totalSupply() / 2)\n         return;\n      if (amount == 0 || amount2 == 0) return;\n      if (delegatee == address(0)) return;\n\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n\n      // Delegate\n      uint256 totalAmount = amount + amount2;\n      ctx.approve(address(delegatorFactory), totalAmount);\n      delegatorFactory.stake(delegator, totalAmount);\n\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, amount);\n      uint256 balDelegatee = ctx.balanceOf(delegatee);\n      uint256 balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker - amount2);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, amount2);\n      assertEq(ctx.getCurrentVotes(delegatee), amount2);\n      assertEq(amount2, delegatorFactory.balanceOf(address(this)));\n      assertEq(amount2, delegatorFactory.totalSupply());\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, amount2);\n      balDelegatee = ctx.balanceOf(delegatee);\n      balDelegator = ctx.balanceOf(delegator);\n      assertEq(ctx.balanceOf(address(this)), prevBalStaker);\n      assertEq(balDelegatee, 0);\n      assertEq(balDelegator, 0);\n      assertEq(ctx.getCurrentVotes(delegatee), 0);\n      assertEq(0, delegatorFactory.balanceOf(address(this)));\n      assertEq(0, delegatorFactory.totalSupply());\n   }\n\n   function testFail_invalidRemoveDelegator() public {\n      uint256 amount = 1 ether;\n      FakeDelegator faker = new FakeDelegator();\n      user1.doRemoveDelegate(delegatorFactory, address(faker), amount);\n   }\n\n   function testFail_invalidRemoveAmount() public {\n      address delegatee = address(0x1);\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n      delegatorFactory.withdraw(delegator, 0);\n   }\n\n   function testFail_invalidUnDelegateAmount(address delegatee, uint256 amount)\n      public\n   {\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n\n      // Delegate\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator, amount);\n\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n\n      // Remove Delegate\n      delegatorFactory.withdraw(delegator, (amount + 1));\n   }\n\n   function test_moveDelegation(uint256 amount, uint256 amount2) public {\n      if (amount > ctx.totalSupply() / 2 || amount2 > ctx.totalSupply() / 2)\n         return;\n      if (amount == 0 || amount2 == 0) return;\n\n      uint256 prevBalStaker = ctx.balanceOf(address(this));\n      address delegatee1 = address(0x1);\n      address delegatee2 = address(0x2);\n      delegatorFactory.createDelegator(delegatee1);\n      delegatorFactory.createDelegator(delegatee2);\n      address delegator1 = delegatorFactory.delegateeToDelegator(delegatee1);\n      address delegator2 = delegatorFactory.delegateeToDelegator(delegatee2);\n      uint256 totalAmount = amount + amount2;\n      ctx.approve(address(delegatorFactory), totalAmount);\n      delegatorFactory.stake(delegator1, totalAmount);\n\n      // Time Skip\n      hevm.warp(waitTime + 1 seconds);\n\n      delegatorFactory.withdraw(delegator1, amount);\n      ctx.approve(address(delegatorFactory), amount);\n      delegatorFactory.stake(delegator2, amount);\n\n      assertEq(\n         ctx.balanceOf(address(this)),\n         prevBalStaker - (amount + amount2)\n      );\n      assertEq(ctx.balanceOf(delegator1), amount2);\n      assertEq(ctx.balanceOf(delegator2), amount);\n      assertEq(ctx.getCurrentVotes(delegatee1), amount2);\n      assertEq(ctx.getCurrentVotes(delegatee2), amount);\n      assertEq(\n         delegatorFactory.stakerWaitTime(address(this), delegator2),\n         2 weeks + 1 seconds\n      );\n      assertEq(amount2 + amount, delegatorFactory.balanceOf(address(this)));\n      assertEq(amount2 + amount, delegatorFactory.totalSupply());\n   }\n\n   function test_updateWaitTime() public {\n      uint256 newTime = 1 weeks;\n      assertEq(delegatorFactory.waitTime(), waitTime);\n      delegatorFactory.updateWaitTime(newTime);\n      assertEq(delegatorFactory.waitTime(), newTime);\n   }\n\n   function test_updateWaitTimeFuzz(uint256 newTime) public {\n      assertEq(delegatorFactory.waitTime(), waitTime);\n      delegatorFactory.updateWaitTime(newTime);\n      assertEq(delegatorFactory.waitTime(), newTime);\n   }\n\n   function testFail_updateWaitTimeNotAdmin(uint256 newTime) public {\n      user1.doUpdateWaitTime(delegatorFactory, newTime);\n   }\n\n   function test_notifyRewards() public {\n      uint256 reward = 1 ether;\n      ctx.transfer(address(delegatorFactory), reward);\n      delegatorFactory.notifyRewardAmount(reward);\n\n      ctx.transfer(address(delegatorFactory), reward);\n      delegatorFactory.notifyRewardAmount(reward);\n   }\n\n   function test_notifyRewardsFuzz(uint256 reward) public {\n      if (reward > ctx.totalSupply()) return;\n      if (reward == 0) return;\n      ctx.transfer(address(delegatorFactory), reward);\n      delegatorFactory.notifyRewardAmount(reward);\n   }\n\n   function testFail_notifyRewards_rewardToHigh() public {\n      delegatorFactory.notifyRewardAmount(1 ether);\n   }\n\n   function testFail_notifyRewards_notOwner() public {\n      user1.doUpdateRewards(delegatorFactory, 1 ether);\n   }\n\n   function test_setRewardsDuration() public {\n      uint256 duration = 1 weeks;\n      hevm.warp(delegatorFactory.periodFinish() + 1);\n      delegatorFactory.setRewardsDuration(duration);\n      uint256 rewardsDuration = delegatorFactory.rewardsDuration();\n      assert(rewardsDuration == duration);\n   }\n\n   function test_setRewardsDurationFuzz(uint256 duration) public {\n      hevm.warp(delegatorFactory.periodFinish() + 1);\n      delegatorFactory.setRewardsDuration(duration);\n      uint256 rewardsDuration = delegatorFactory.rewardsDuration();\n      assert(rewardsDuration == duration);\n   }\n\n   function testFail_setRewardsDuration_notOwner() public {\n      user1.doSetRewardsDuration(delegatorFactory, 1 weeks);\n   }\n\n   function testFail_setRewardsDuration_rewardsNotComplete(uint256 duration)\n      public\n   {\n      delegatorFactory.setRewardsDuration(duration);\n      delegatorFactory.setRewardsDuration(duration);\n   }\n\n   function test_earnRewards() public {\n      uint256 amount = 1 ether;\n      address delegatee = address(0x1);\n      uint256 lastUpdateTime = delegatorFactory.lastUpdateTime();\n      uint256 lastRewardPerTokenStored = delegatorFactory\n         .rewardPerTokenStored();\n      uint256 lastUserRewardPerTokenPaid = delegatorFactory\n         .userRewardPerTokenPaid(address(user1));\n\n      assertEq(lastUpdateTime, 0);\n      assertEq(lastRewardPerTokenStored, 0);\n      assertEq(lastUserRewardPerTokenPaid, 0);\n\n      // create delegator\n      delegatorFactory.createDelegator(delegatee);\n      address delegator = delegatorFactory.delegateeToDelegator(delegatee);\n      address delegateeResult = delegatorFactory.delegatorToDelegatee(\n         delegator\n      );\n      assertEq(delegateeResult, delegatee);\n      assertTrue(delegatorFactory.delegators(delegator));\n\n      // Delegate\n      ctx.transfer(address(user1), amount);\n      user1.approveAmount(ctx, delegatorFactory, amount);\n      user1.doDelegate(delegatorFactory, delegator, amount / 2);\n      hevm.warp(2 days);\n      assertEq(delegatorFactory.earned(address(user1)), 0);\n      assertEq(delegatorFactory.rewards(address(user1)), 0);\n\n      // Start Rewards\n      uint256 reward = 250000 ether;\n      ctx.transfer(address(delegatorFactory), reward);\n      delegatorFactory.notifyRewardAmount(reward);\n\n      // check if rewards increase\n      uint256 prevReward = delegatorFactory.earned(address(user1));\n      assertEq(prevReward, 0);\n\n      hevm.warp(1 weeks);\n      uint256 newReward = delegatorFactory.earned(address(user1));\n      assertTrue(newReward > prevReward);\n      prevReward = newReward;\n      user1.doDelegate(delegatorFactory, delegator, amount / 2);\n      assert(delegatorFactory.rewards(address(user1)) > 0);\n\n      hevm.warp(2 weeks);\n      newReward = delegatorFactory.earned(address(user1));\n      assertTrue(newReward > prevReward);\n      prevReward = newReward;\n      uint256 prevBal = ctx.balanceOf(address(user1));\n      user1.doClaimRewards(delegatorFactory);\n      uint256 newBal = ctx.balanceOf(address(user1));\n      uint256 updateTime = delegatorFactory.lastUpdateTime();\n      uint256 rewardPerTokenStored = delegatorFactory.rewardPerTokenStored();\n      uint256 userRewardPerTokenPaid = delegatorFactory.userRewardPerTokenPaid(\n         address(user1)\n      );\n\n      assertTrue(newBal > prevBal);\n      assert(updateTime > lastUpdateTime);\n      assertEq(updateTime, block.timestamp);\n      assert(rewardPerTokenStored > lastRewardPerTokenStored);\n      assert(userRewardPerTokenPaid > lastRewardPerTokenStored);\n\n      // warp to end\n      hevm.warp(delegatorFactory.rewardsDuration());\n      newReward = delegatorFactory.earned(address(user1));\n      assertTrue(newReward > prevReward);\n\n      // claim rewards\n      prevBal = ctx.balanceOf(address(user1));\n      user1.doClaimRewards(delegatorFactory);\n      newBal = ctx.balanceOf(address(user1));\n      assertTrue(newBal > prevBal);\n      assertEq(delegatorFactory.rewards(address(user1)), 0);\n   }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n   event log(string);\n   event logs(bytes);\n\n   event log_address(address);\n   event log_bytes32(bytes32);\n   event log_int(int256);\n   event log_uint(uint256);\n   event log_bytes(bytes);\n   event log_string(string);\n\n   event log_named_address(string key, address val);\n   event log_named_bytes32(string key, bytes32 val);\n   event log_named_decimal_int(string key, int256 val, uint256 decimals);\n   event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n   event log_named_int(string key, int256 val);\n   event log_named_uint(string key, uint256 val);\n   event log_named_bytes(string key, bytes val);\n   event log_named_string(string key, string val);\n\n   bool public IS_TEST = true;\n   bool public failed;\n\n   address constant HEVM_ADDRESS =\n      address(bytes20(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n   modifier mayRevert() {\n      _;\n   }\n   modifier testopts(string memory) {\n      _;\n   }\n\n   function fail() internal {\n      failed = true;\n   }\n\n   modifier logs_gas() {\n      uint256 startGas = gasleft();\n      _;\n      uint256 endGas = gasleft();\n      emit log_named_uint(\"gas\", startGas - endGas);\n   }\n\n   function assertTrue(bool condition) internal {\n      if (!condition) {\n         emit log(\"Error: Assertion Failed\");\n         fail();\n      }\n   }\n\n   function assertTrue(bool condition, string memory err) internal {\n      if (!condition) {\n         emit log_named_string(\"Error\", err);\n         assertTrue(condition);\n      }\n   }\n\n   function assertEq(address a, address b) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [address]\");\n         emit log_named_address(\"  Expected\", b);\n         emit log_named_address(\"    Actual\", a);\n         fail();\n      }\n   }\n\n   function assertEq(\n      address a,\n      address b,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEq(a, b);\n      }\n   }\n\n   function assertEq(bytes32 a, bytes32 b) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [bytes32]\");\n         emit log_named_bytes32(\"  Expected\", b);\n         emit log_named_bytes32(\"    Actual\", a);\n         fail();\n      }\n   }\n\n   function assertEq(\n      bytes32 a,\n      bytes32 b,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEq(a, b);\n      }\n   }\n\n   function assertEq32(bytes32 a, bytes32 b) internal {\n      assertEq(a, b);\n   }\n\n   function assertEq32(\n      bytes32 a,\n      bytes32 b,\n      string memory err\n   ) internal {\n      assertEq(a, b, err);\n   }\n\n   function assertEq(int256 a, int256 b) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [int]\");\n         emit log_named_int(\"  Expected\", b);\n         emit log_named_int(\"    Actual\", a);\n         fail();\n      }\n   }\n\n   function assertEq(\n      int256 a,\n      int256 b,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEq(a, b);\n      }\n   }\n\n   function assertEq(uint256 a, uint256 b) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [uint]\");\n         emit log_named_uint(\"  Expected\", b);\n         emit log_named_uint(\"    Actual\", a);\n         fail();\n      }\n   }\n\n   function assertEq(\n      uint256 a,\n      uint256 b,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEq(a, b);\n      }\n   }\n\n   function assertEqDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals\n   ) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [decimal int]\");\n         emit log_named_decimal_int(\"  Expected\", b, decimals);\n         emit log_named_decimal_int(\"    Actual\", a, decimals);\n         fail();\n      }\n   }\n\n   function assertEqDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEqDecimal(a, b, decimals);\n      }\n   }\n\n   function assertEqDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals\n   ) internal {\n      if (a != b) {\n         emit log(\"Error: a == b not satisfied [decimal uint]\");\n         emit log_named_decimal_uint(\"  Expected\", b, decimals);\n         emit log_named_decimal_uint(\"    Actual\", a, decimals);\n         fail();\n      }\n   }\n\n   function assertEqDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a != b) {\n         emit log_named_string(\"Error\", err);\n         assertEqDecimal(a, b, decimals);\n      }\n   }\n\n   function assertGt(uint256 a, uint256 b) internal {\n      if (a <= b) {\n         emit log(\"Error: a > b not satisfied [uint]\");\n         emit log_named_uint(\"  Value a\", a);\n         emit log_named_uint(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertGt(\n      uint256 a,\n      uint256 b,\n      string memory err\n   ) internal {\n      if (a <= b) {\n         emit log_named_string(\"Error\", err);\n         assertGt(a, b);\n      }\n   }\n\n   function assertGt(int256 a, int256 b) internal {\n      if (a <= b) {\n         emit log(\"Error: a > b not satisfied [int]\");\n         emit log_named_int(\"  Value a\", a);\n         emit log_named_int(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertGt(\n      int256 a,\n      int256 b,\n      string memory err\n   ) internal {\n      if (a <= b) {\n         emit log_named_string(\"Error\", err);\n         assertGt(a, b);\n      }\n   }\n\n   function assertGtDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals\n   ) internal {\n      if (a <= b) {\n         emit log(\"Error: a > b not satisfied [decimal int]\");\n         emit log_named_decimal_int(\"  Value a\", a, decimals);\n         emit log_named_decimal_int(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertGtDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a <= b) {\n         emit log_named_string(\"Error\", err);\n         assertGtDecimal(a, b, decimals);\n      }\n   }\n\n   function assertGtDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals\n   ) internal {\n      if (a <= b) {\n         emit log(\"Error: a > b not satisfied [decimal uint]\");\n         emit log_named_decimal_uint(\"  Value a\", a, decimals);\n         emit log_named_decimal_uint(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertGtDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a <= b) {\n         emit log_named_string(\"Error\", err);\n         assertGtDecimal(a, b, decimals);\n      }\n   }\n\n   function assertGe(uint256 a, uint256 b) internal {\n      if (a < b) {\n         emit log(\"Error: a >= b not satisfied [uint]\");\n         emit log_named_uint(\"  Value a\", a);\n         emit log_named_uint(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertGe(\n      uint256 a,\n      uint256 b,\n      string memory err\n   ) internal {\n      if (a < b) {\n         emit log_named_string(\"Error\", err);\n         assertGe(a, b);\n      }\n   }\n\n   function assertGe(int256 a, int256 b) internal {\n      if (a < b) {\n         emit log(\"Error: a >= b not satisfied [int]\");\n         emit log_named_int(\"  Value a\", a);\n         emit log_named_int(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertGe(\n      int256 a,\n      int256 b,\n      string memory err\n   ) internal {\n      if (a < b) {\n         emit log_named_string(\"Error\", err);\n         assertGe(a, b);\n      }\n   }\n\n   function assertGeDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals\n   ) internal {\n      if (a < b) {\n         emit log(\"Error: a >= b not satisfied [decimal int]\");\n         emit log_named_decimal_int(\"  Value a\", a, decimals);\n         emit log_named_decimal_int(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertGeDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a < b) {\n         emit log_named_string(\"Error\", err);\n         assertGeDecimal(a, b, decimals);\n      }\n   }\n\n   function assertGeDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals\n   ) internal {\n      if (a < b) {\n         emit log(\"Error: a >= b not satisfied [decimal uint]\");\n         emit log_named_decimal_uint(\"  Value a\", a, decimals);\n         emit log_named_decimal_uint(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertGeDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a < b) {\n         emit log_named_string(\"Error\", err);\n         assertGeDecimal(a, b, decimals);\n      }\n   }\n\n   function assertLt(uint256 a, uint256 b) internal {\n      if (a >= b) {\n         emit log(\"Error: a < b not satisfied [uint]\");\n         emit log_named_uint(\"  Value a\", a);\n         emit log_named_uint(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertLt(\n      uint256 a,\n      uint256 b,\n      string memory err\n   ) internal {\n      if (a >= b) {\n         emit log_named_string(\"Error\", err);\n         assertLt(a, b);\n      }\n   }\n\n   function assertLt(int256 a, int256 b) internal {\n      if (a >= b) {\n         emit log(\"Error: a < b not satisfied [int]\");\n         emit log_named_int(\"  Value a\", a);\n         emit log_named_int(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertLt(\n      int256 a,\n      int256 b,\n      string memory err\n   ) internal {\n      if (a >= b) {\n         emit log_named_string(\"Error\", err);\n         assertLt(a, b);\n      }\n   }\n\n   function assertLtDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals\n   ) internal {\n      if (a >= b) {\n         emit log(\"Error: a < b not satisfied [decimal int]\");\n         emit log_named_decimal_int(\"  Value a\", a, decimals);\n         emit log_named_decimal_int(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertLtDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a >= b) {\n         emit log_named_string(\"Error\", err);\n         assertLtDecimal(a, b, decimals);\n      }\n   }\n\n   function assertLtDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals\n   ) internal {\n      if (a >= b) {\n         emit log(\"Error: a < b not satisfied [decimal uint]\");\n         emit log_named_decimal_uint(\"  Value a\", a, decimals);\n         emit log_named_decimal_uint(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertLtDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a >= b) {\n         emit log_named_string(\"Error\", err);\n         assertLtDecimal(a, b, decimals);\n      }\n   }\n\n   function assertLe(uint256 a, uint256 b) internal {\n      if (a > b) {\n         emit log(\"Error: a <= b not satisfied [uint]\");\n         emit log_named_uint(\"  Value a\", a);\n         emit log_named_uint(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertLe(\n      uint256 a,\n      uint256 b,\n      string memory err\n   ) internal {\n      if (a > b) {\n         emit log_named_string(\"Error\", err);\n         assertLe(a, b);\n      }\n   }\n\n   function assertLe(int256 a, int256 b) internal {\n      if (a > b) {\n         emit log(\"Error: a <= b not satisfied [int]\");\n         emit log_named_int(\"  Value a\", a);\n         emit log_named_int(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertLe(\n      int256 a,\n      int256 b,\n      string memory err\n   ) internal {\n      if (a > b) {\n         emit log_named_string(\"Error\", err);\n         assertLe(a, b);\n      }\n   }\n\n   function assertLeDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals\n   ) internal {\n      if (a > b) {\n         emit log(\"Error: a <= b not satisfied [decimal int]\");\n         emit log_named_decimal_int(\"  Value a\", a, decimals);\n         emit log_named_decimal_int(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertLeDecimal(\n      int256 a,\n      int256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a > b) {\n         emit log_named_string(\"Error\", err);\n         assertLeDecimal(a, b, decimals);\n      }\n   }\n\n   function assertLeDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals\n   ) internal {\n      if (a > b) {\n         emit log(\"Error: a <= b not satisfied [decimal uint]\");\n         emit log_named_decimal_uint(\"  Value a\", a, decimals);\n         emit log_named_decimal_uint(\"  Value b\", b, decimals);\n         fail();\n      }\n   }\n\n   function assertLeDecimal(\n      uint256 a,\n      uint256 b,\n      uint256 decimals,\n      string memory err\n   ) internal {\n      if (a > b) {\n         emit log_named_string(\"Error\", err);\n         assertGeDecimal(a, b, decimals);\n      }\n   }\n\n   function assertEq(string memory a, string memory b) internal {\n      if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n         emit log(\"Error: a == b not satisfied [string]\");\n         emit log_named_string(\"  Value a\", a);\n         emit log_named_string(\"  Value b\", b);\n         fail();\n      }\n   }\n\n   function assertEq(\n      string memory a,\n      string memory b,\n      string memory err\n   ) internal {\n      if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n         emit log_named_string(\"Error\", err);\n         assertEq(a, b);\n      }\n   }\n\n   function checkEq0(bytes memory a, bytes memory b)\n      internal\n      pure\n      returns (bool ok)\n   {\n      ok = true;\n      if (a.length == b.length) {\n         for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n               ok = false;\n            }\n         }\n      } else {\n         ok = false;\n      }\n   }\n\n   function assertEq0(bytes memory a, bytes memory b) internal {\n      if (!checkEq0(a, b)) {\n         emit log(\"Error: a == b not satisfied [bytes]\");\n         emit log_named_bytes(\"  Expected\", a);\n         emit log_named_bytes(\"    Actual\", b);\n         fail();\n      }\n   }\n\n   function assertEq0(\n      bytes memory a,\n      bytes memory b,\n      string memory err\n   ) internal {\n      if (!checkEq0(a, b)) {\n         emit log_named_string(\"Error\", err);\n         assertEq0(a, b);\n      }\n   }\n}\n"
    },
    "src/tests/hevm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.23;\n\ninterface Hevm {\n   function warp(uint256 x) external;\n\n   function roll(uint256 x) external;\n\n   function store(\n      address c,\n      bytes32 loc,\n      bytes32 val\n   ) external;\n\n   function load(address c, bytes32 loc) external returns (bytes32 val);\n\n   function sign(uint256 sk, bytes32 digest)\n      external\n      returns (\n         uint8 v,\n         bytes32 r,\n         bytes32 s\n      );\n\n   function addr(uint256 sk) external returns (address addr);\n\n   function ffi(string[] calldata) external returns (bytes memory);\n}\n"
    },
    "src/DelegatorFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IGovernanceToken.sol\";\nimport \"./Delegator.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title Delegator Contract Factory\n * @author Cryptex.Finance\n * @notice Contract in charge of generating Delegator contracts, handling delegations and CTX balance map, rewards.\n */\n\ncontract DelegatorFactory is Ownable, ReentrancyGuard {\n   /* ========== STATE VARIABLES ========== */\n\n   /// @notice Address of the staking governance token\n   address public immutable stakingToken;\n\n   /// @notice Address of the reward token\n   address public immutable rewardsToken;\n\n   /// @notice Minimum wait time before removing stake\n   uint256 public waitTime;\n\n   /// @notice Tracks the period where users stop earning rewards\n   uint256 public periodFinish = 0;\n   uint256 public rewardRate = 0;\n\n   /// @notice How long the rewards lasts, it updates when more rewards are added\n   uint256 public rewardsDuration = 186 days;\n\n   /// @notice Last time rewards were updated\n   uint256 public lastUpdateTime;\n\n   /// @notice Amount of reward calculated per token stored\n   uint256 public rewardPerTokenStored;\n\n   /// @notice Track the rewards paid to users\n   mapping(address => uint256) public userRewardPerTokenPaid;\n\n   /// @notice Tracks the user rewards\n   mapping(address => uint256) public rewards;\n\n   /// @notice Tracks the address of a delegatee with a delegator contract address\n   mapping(address => address) public delegatorToDelegatee;\n\n   /// @notice Tracks the delegator contract address from delegatee address\n   mapping(address => address) public delegateeToDelegator;\n\n   /// @notice Tracks if address is an official delegator\n   mapping(address => bool) public delegators;\n\n   /// @notice Tracks minimum wait time the account has to wait before removing stake\n   mapping(address => mapping(address => uint256)) public stakerWaitTime;\n\n   /// @dev Tracks the total supply of staked tokens\n   uint256 private _totalSupply;\n\n   /// @dev Tracks the amount of staked tokens per user\n   mapping(address => uint256) private _balances;\n\n   /* ========== EVENTS ========== */\n\n   /// @notice An event emitted when a Delegator is created\n   event DelegatorCreated(address indexed delegator, address indexed delegatee);\n\n   /// @notice An event emitted when an user has staked and delegated\n   event Staked(\n      address indexed delegator,\n      address indexed delegatee,\n      uint256 amount\n   );\n\n   /// @notice An event emitted when an user removes stake and undelegated\n   event Withdrawn(\n      address indexed delegator,\n      address indexed delegatee,\n      uint256 amount\n   );\n\n   /// @notice An event emitted when the minimum wait time is updated\n   event WaitTimeUpdated(uint256 waitTime);\n\n   /// @notice An event emitted when a reward is added\n   event RewardAdded(uint256 reward);\n\n   /// @notice An event emitted when reward is paid to a user\n   event RewardPaid(address indexed user, uint256 reward);\n\n   /// @notice An event emitted when the rewards duration is updated\n   event RewardsDurationUpdated(uint256 newDuration);\n\n   /* ========== CONSTRUCTOR ========== */\n\n   /**\n    * @notice Constructor\n    * @param stakingToken_ address\n    * @param rewardsToken_ address\n    * @param waitTime_ uint256\n    * @param timelock_ address\n    * @dev transfers ownership to timelock\n    */\n   constructor(\n      address stakingToken_,\n      address rewardsToken_,\n      uint256 waitTime_,\n      address timelock_\n   ) {\n      require(\n         stakingToken_ != address(0) &&\n            rewardsToken_ != address(0) &&\n            timelock_ != address(0),\n         \"Address can't be 0\"\n      );\n      require(\n         IGovernanceToken(stakingToken_).decimals() == 18 &&\n            IGovernanceToken(rewardsToken_).decimals() == 18,\n         \"Decimals must be 18\"\n      );\n      stakingToken = stakingToken_;\n      rewardsToken = rewardsToken_;\n      waitTime = waitTime_;\n      transferOwnership(timelock_);\n   }\n\n   /* ========== MUTATIVE FUNCTIONS ========== */\n\n   /**\n    * @notice Updates the reward and time on call.\n    * @param account_ address\n    */\n   function updateReward(address account_) private {\n      rewardPerTokenStored = rewardPerToken();\n      lastUpdateTime = lastTimeRewardApplicable();\n\n      if (account_ != address(0)) {\n         rewards[account_] = currentEarned(account_);\n         userRewardPerTokenPaid[account_] = rewardPerTokenStored;\n      }\n   }\n\n   /**\n    * @notice Notifies the contract that reward has been added to be given.\n    * @param reward_ uint\n    * @dev Only owner  can call it\n    * @dev Increases duration of rewards\n    */\n   function notifyRewardAmount(uint256 reward_) external onlyOwner {\n      updateReward(address(0));\n      if (block.timestamp >= periodFinish) {\n         rewardRate = reward_ / rewardsDuration;\n      } else {\n         uint256 remaining = periodFinish - block.timestamp;\n         uint256 leftover = remaining * rewardRate;\n         rewardRate = (reward_ + leftover) / rewardsDuration;\n      }\n\n      lastUpdateTime = block.timestamp;\n      periodFinish = block.timestamp + rewardsDuration;\n\n      // Ensure the provided reward amount is not more than the balance in the contract.\n      // This keeps the reward rate in the right range, preventing overflows due to\n      // very high values of rewardRate in the earned and rewardsPerToken functions;\n      // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n      uint256 balance = IGovernanceToken(rewardsToken).balanceOf(address(this));\n      require(\n         rewardRate <= balance / rewardsDuration,\n         \"Provided reward too high\"\n      );\n      emit RewardAdded(reward_);\n   }\n\n   /**\n    * @notice  Updates the reward duration\n    * @param rewardsDuration_ uint\n    * @dev Only owner can call it\n    * @dev Previous rewards must be complete\n    */\n   function setRewardsDuration(uint256 rewardsDuration_) external onlyOwner {\n      require(\n         block.timestamp > periodFinish,\n         \"Previous rewards period must be complete before changing the duration for the new period\"\n      );\n      rewardsDuration = rewardsDuration_;\n      emit RewardsDurationUpdated(rewardsDuration);\n   }\n\n   /**\n    * @notice Transfers to the caller the current amount of rewards tokens earned.\n    * @dev updates rewards on call\n    */\n   function getReward() external nonReentrant {\n      updateReward(msg.sender);\n      uint256 reward = rewards[msg.sender];\n      if (reward > 0) {\n         rewards[msg.sender] = 0;\n         require(\n            IGovernanceToken(rewardsToken).transfer(msg.sender, reward),\n            \"Transfer Failed\"\n         );\n         emit RewardPaid(msg.sender, reward);\n      }\n   }\n\n   /**\n    * @notice Creates a new delegator contract that delegates all votes to delegatee_\n    * @param delegatee_ address that will be receiving all votes\n    * @dev only one delegator contract pointing to the same delegatee can exist\n    */\n   function createDelegator(address delegatee_) external {\n      require(delegatee_ != address(0), \"Delegatee can't be 0\");\n      require(\n         delegateeToDelegator[delegatee_] == address(0),\n         \"Delegator already created\"\n      );\n      Delegator delegator = new Delegator(delegatee_, stakingToken);\n      delegateeToDelegator[delegatee_] = address(delegator);\n      delegatorToDelegatee[address(delegator)] = delegatee_;\n      delegators[address(delegator)] = true;\n      emit DelegatorCreated(address(delegator), delegatee_);\n   }\n\n   /**\n    * @notice Stakes to delegator_ the amount_ specified\n    * @param delegator_ contract address where to send the amount_\n    * @param amount_ uint to be staked and delegated\n    * @dev Delegator must be valid and amount has to be greater than 0\n    * @dev amount_ is transferred to the delegator contract and staker starts earning rewards if active\n    * @dev updates rewards on call\n    */\n   function stake(address delegator_, uint256 amount_) external nonReentrant {\n      require(delegators[delegator_], \"Not a valid delegator\");\n      require(amount_ > 0, \"Amount must be greater than 0\");\n      updateReward(msg.sender);\n      _totalSupply = _totalSupply + amount_;\n      _balances[msg.sender] = _balances[msg.sender] + amount_;\n      Delegator d = Delegator(delegator_);\n      d.stake(msg.sender, amount_);\n      stakerWaitTime[msg.sender][delegator_] = block.timestamp + waitTime;\n      require(\n         IGovernanceToken(stakingToken).transferFrom(\n            msg.sender,\n            delegator_,\n            amount_\n         ),\n         \"Transfer Failed\"\n      );\n      emit Staked(delegator_, msg.sender, amount_);\n   }\n\n   /**\n    * @notice Removes amount_ from delegator_\n    * @param delegator_ contract address where to remove the stake from\n    * @param amount_ uint to be removed from stake and undelegated\n    * @dev Delegator must be valid and amount has to be greater than 0\n    * @dev amount_ must be <= that current user stake\n    * @dev amount_ is transferred from the  delegator contract to the staker\n    * @dev updates rewards on call\n    * @dev requires that at least waitTime has passed since delegation to unDelegate\n    */\n   function withdraw(address delegator_, uint256 amount_)\n      external\n      nonReentrant\n   {\n      require(delegators[delegator_], \"Not a valid delegator\");\n      require(amount_ > 0, \"Amount must be greater than 0\");\n      require(\n         block.timestamp >= stakerWaitTime[msg.sender][delegator_],\n         \"Need to wait the minimum staking period\"\n      );\n      updateReward(msg.sender);\n      _totalSupply = _totalSupply - amount_;\n      _balances[msg.sender] = _balances[msg.sender] - amount_;\n      Delegator d = Delegator(delegator_);\n      d.removeStake(msg.sender, amount_);\n      emit Withdrawn(delegator_, msg.sender, amount_);\n   }\n\n   /**\n    * @notice updates the min wait time between delegation and unDelegation\n    * @param waitTime_ uint new wait time\n    * @dev only the owner can call it\n    */\n   function updateWaitTime(uint256 waitTime_) external onlyOwner {\n      waitTime = waitTime_;\n      emit WaitTimeUpdated(waitTime_);\n   }\n\n   /* ========== VIEWS ========== */\n\n   /**\n    * @notice Returns the amount of reward tokens a user has earned.\n    * @param account_ address\n    */\n   function currentEarned(address account_) private view returns (uint256) {\n      return\n         (_balances[account_] *\n            (rewardPerTokenStored - userRewardPerTokenPaid[account_])) /\n         1e18 +\n         rewards[account_];\n   }\n\n   /// @notice Returns the total amount of staked tokens.\n   function totalSupply() external view returns (uint256) {\n      return _totalSupply;\n   }\n\n   /**\n    * @notice Returns the amount of staked tokens from specific user\n    * @param account_ address\n    */\n   function balanceOf(address account_) external view returns (uint256) {\n      return _balances[account_];\n   }\n\n   /// @notice Returns reward rate for a duration\n   function getRewardForDuration() external view returns (uint256) {\n      return rewardRate * rewardsDuration;\n   }\n\n   /// @notice Returns the minimum between current block timestamp or the finish period of rewards.\n   function lastTimeRewardApplicable() public view returns (uint256) {\n      return min(block.timestamp, periodFinish);\n   }\n\n   /// @notice Returns the calculated reward per token deposited.\n   function rewardPerToken() public view returns (uint256) {\n      if (_totalSupply == 0) {\n         return rewardPerTokenStored;\n      }\n\n      return\n         rewardPerTokenStored +\n         ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) /\n         _totalSupply;\n   }\n\n   /**\n    * @notice Returns the amount of reward tokens a user has earned.\n    * @param account_ address\n    */\n   function earned(address account_) public view returns (uint256) {\n      return\n         (_balances[account_] *\n            (rewardPerToken() - userRewardPerTokenPaid[account_])) /\n         1e18 +\n         rewards[account_];\n   }\n\n   /**\n    * @notice Returns the minimum between two variables\n    * @param a_ uint\n    * @param b_ uint\n    */\n   function min(uint256 a_, uint256 b_) public pure returns (uint256) {\n      return a_ < b_ ? a_ : b_;\n   }\n}\n"
    },
    "src/mocks/GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\npragma experimental ABIEncoderV2;\n\ncontract GovernanceToken {\n   /// @notice EIP-20 token name for this token\n   string public constant name = \"Cryptex\";\n\n   /// @notice EIP-20 token symbol for this token\n   string public constant symbol = \"CTX\";\n\n   /// @notice EIP-20 token decimals for this token\n   uint8 public constant decimals = 18;\n\n   /// @notice Total number of tokens in circulation\n   uint256 public totalSupply = 10000000e18; // 10 million CTX\n\n   /// @notice Address which may mint new tokens\n   address public minter;\n\n   /// @notice The timestamp after which minting may occur\n   uint256 public mintingAllowedAfter;\n\n   /// @notice Minimum time between mints\n   uint32 public constant minimumTimeBetweenMints = 1 days * 365;\n\n   /// @notice Cap on the percentage of totalSupply that can be minted at each mint\n   uint8 public constant mintCap = 2;\n\n   /// @dev Allowance amounts on behalf of others\n   mapping(address => mapping(address => uint96)) internal allowances;\n\n   /// @dev Official record of token balances for each account\n   mapping(address => uint96) internal balances;\n\n   /// @notice A record of each accounts delegate\n   mapping(address => address) public delegates;\n\n   /// @notice A checkpoint for marking number of votes from a given block\n   struct Checkpoint {\n      uint32 fromBlock;\n      uint96 votes;\n   }\n\n   /// @notice A record of votes checkpoints for each account, by index\n   mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n   /// @notice The number of checkpoints for each account\n   mapping(address => uint32) public numCheckpoints;\n\n   /// @notice The EIP-712 typehash for the contract's domain\n   bytes32 public constant DOMAIN_TYPEHASH =\n      keccak256(\n         \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n      );\n\n   /// @notice The EIP-712 typehash for the delegation struct used by the contract\n   bytes32 public constant DELEGATION_TYPEHASH =\n      keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n   /// @notice The EIP-712 typehash for the permit struct used by the contract\n   bytes32 public constant PERMIT_TYPEHASH =\n      keccak256(\n         \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n      );\n\n   /// @notice A record of states for signing / validating signatures\n   mapping(address => uint256) public nonces;\n\n   /// @notice An event thats emitted when the minter address is changed\n   event MinterChanged(address minter, address newMinter);\n\n   /// @notice An event thats emitted when an account changes its delegate\n   event DelegateChanged(\n      address indexed delegator,\n      address indexed fromDelegate,\n      address indexed toDelegate\n   );\n\n   /// @notice An event thats emitted when a delegate account's vote balance changes\n   event DelegateVotesChanged(\n      address indexed delegate,\n      uint256 previousBalance,\n      uint256 newBalance\n   );\n\n   /// @notice The standard EIP-20 transfer event\n   event Transfer(address indexed from, address indexed to, uint256 amount);\n\n   /// @notice The standard EIP-20 approval event\n   event Approval(\n      address indexed owner,\n      address indexed spender,\n      uint256 amount\n   );\n\n   /**\n    * @notice Construct a new Ctx token\n    * @param account The initial account to grant all the tokens\n    * @param minter_ The account with minting ability\n    * @param mintingAllowedAfter_ The timestamp after which minting may occur\n    */\n   constructor(\n      address account,\n      address minter_,\n      uint256 mintingAllowedAfter_\n   ) {\n      require(\n         mintingAllowedAfter_ >= block.timestamp,\n         \"Ctx::constructor: minting can only begin after deployment\"\n      );\n\n      balances[account] = uint96(totalSupply);\n      emit Transfer(address(0), account, totalSupply);\n      minter = minter_;\n      emit MinterChanged(address(0), minter);\n      mintingAllowedAfter = mintingAllowedAfter_;\n   }\n\n   /**\n    * @notice Change the minter address\n    * @param minter_ The address of the new minter\n    */\n   function setMinter(address minter_) external {\n      require(\n         msg.sender == minter,\n         \"Ctx::setMinter: only the minter can change the minter address\"\n      );\n      emit MinterChanged(minter, minter_);\n      minter = minter_;\n   }\n\n   /**\n    * @notice Mint new tokens\n    * @param dst The address of the destination account\n    * @param rawAmount The number of tokens to be minted\n    */\n   function mint(address dst, uint256 rawAmount) external {\n      require(msg.sender == minter, \"Ctx::mint: only the minter can mint\");\n      require(\n         block.timestamp >= mintingAllowedAfter,\n         \"Ctx::mint: minting not allowed yet\"\n      );\n      require(\n         dst != address(0),\n         \"Ctx::mint: cannot transfer to the zero address\"\n      );\n      require(\n         dst != address(this),\n         \"Ctx::mint: cannot transfer to the Ctx address\"\n      );\n\n      // record the mint\n      mintingAllowedAfter = block.timestamp + minimumTimeBetweenMints;\n\n      // mint the amount\n      uint96 amount = safe96(rawAmount, \"Ctx::mint: amount exceeds 96 bits\");\n      require(\n         amount <= (totalSupply * mintCap) / 100,\n         \"Ctx::mint: exceeded mint cap\"\n      );\n      totalSupply = safe96(\n         (totalSupply + amount),\n         \"Ctx::mint: totalSupply exceeds 96 bits\"\n      );\n\n      // transfer the amount to the recipient\n      balances[dst] = add96(\n         balances[dst],\n         amount,\n         \"Ctx::mint: transfer amount overflows\"\n      );\n      emit Transfer(address(0), dst, amount);\n\n      // move delegates\n      _moveDelegates(address(0), delegates[dst], amount);\n   }\n\n   /**\n    * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    * @param account The address of the account holding the funds\n    * @param spender The address of the account spending the funds\n    * @return The number of tokens approved\n    */\n   function allowance(address account, address spender)\n      external\n      view\n      returns (uint256)\n   {\n      return allowances[account][spender];\n   }\n\n   /**\n    * @notice Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n    * @param owner The address of the caller.\n    * @param spender The address of the account which may transfer tokens\n    * @param amount The number of tokens that are approved\n    * @dev This internal function is equivalent to `approve`, and can be used to\n    * e.g. set automatic allowances for certain subsystems, etc.\n    * @dev Emits an Approval event.\n    * @dev owner cannot be the zero address.\n    * @dev spender cannot be the zero address.\n    */\n   function _approve(\n      address owner,\n      address spender,\n      uint96 amount\n   ) internal virtual {\n      require(\n         owner != address(0),\n         \"Ctx::_approve: approve from the zero address\"\n      );\n      require(\n         spender != address(0),\n         \"Ctx::_approve: approve to the zero address\"\n      );\n\n      allowances[owner][spender] = amount;\n      emit Approval(owner, spender, amount);\n   }\n\n   /**\n    * @notice Approve `spender` to transfer up to `amount` from `src`\n    * @param spender The address of the account which may transfer tokens\n    * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    * @dev This will overwrite the approval amount for `spender`\n    *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    * @return Whether or not the approval succeeded\n    */\n   function approve(address spender, uint256 rawAmount)\n      external\n      returns (bool)\n   {\n      uint96 amount;\n      if (rawAmount == type(uint256).max) {\n         amount = type(uint96).max;\n      } else {\n         amount = safe96(rawAmount, \"Ctx::approve: amount exceeds 96 bits\");\n      }\n      _approve(msg.sender, spender, amount);\n      return true;\n   }\n\n   /**\n    * @notice Atomically increases the allowance granted to `spender` by the caller.\n    * @param spender address\n    * @param addedValue uint256 raw\n    * @dev This is an alternative to {approve} that can be used as a mitigation for\n    * problems of Allowance Double-Spend Exploit.\n    * @dev Emits Approval event indicating the updated allowance.\n    * @dev spender cannot be the zero address.\n    */\n   function increaseAllowance(address spender, uint256 addedValue)\n      public\n      virtual\n      returns (bool)\n   {\n      uint96 amount;\n      if (addedValue == type(uint256).max) {\n         amount = type(uint96).max;\n      } else {\n         amount = safe96(\n            addedValue,\n            \"Ctx::increaseAllowance: amount exceeds 96 bits\"\n         );\n      }\n      _approve(\n         msg.sender,\n         spender,\n         add96(\n            allowances[msg.sender][spender],\n            amount,\n            \"Ctx::increaseAllowance: transfer amount overflows\"\n         )\n      );\n      return true;\n   }\n\n   /**\n    * @notice Atomically decreases the allowance granted to `spender` by the caller.\n    * @param spender address\n    * @param subtractedValue uint256 raw\n    * @dev This is an alternative to {approve} that can be used as a mitigation for\n    * problems of Allowance Double-Spend Exploit.\n    * @dev Emits an Approval event indicating the updated allowance.\n    * @dev spender cannot be the sero address\n    * @dev spender must have allowance for the caller of at least subtractedValue\n    */\n   function decreaseAllowance(address spender, uint256 subtractedValue)\n      public\n      virtual\n      returns (bool)\n   {\n      uint96 amount;\n      if (subtractedValue == type(uint256).max) {\n         amount = type(uint96).max;\n      } else {\n         amount = safe96(\n            subtractedValue,\n            \"Ctx::decreaseAllowance: amount exceeds 96 bits\"\n         );\n      }\n\n      _approve(\n         msg.sender,\n         spender,\n         sub96(\n            allowances[msg.sender][spender],\n            amount,\n            \"Ctx::decreaseAllowance: decreased allowance below zero\"\n         )\n      );\n      return true;\n   }\n\n   /**\n    * @notice Triggers an approval from owner to spends\n    * @param owner The address to approve from\n    * @param spender The address to be approved\n    * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    * @param deadline The time at which to expire the signature\n    * @param v The recovery byte of the signature\n    * @param r Half of the ECDSA signature pair\n    * @param s Half of the ECDSA signature pair\n    */\n   function permit(\n      address owner,\n      address spender,\n      uint256 rawAmount,\n      uint256 deadline,\n      uint8 v,\n      bytes32 r,\n      bytes32 s\n   ) external {\n      uint96 amount;\n      if (rawAmount == type(uint256).max) {\n         amount = type(uint96).max;\n      } else {\n         amount = safe96(rawAmount, \"Ctx::permit: amount exceeds 96 bits\");\n      }\n\n      bytes32 domainSeparator = keccak256(\n         abi.encode(\n            DOMAIN_TYPEHASH,\n            keccak256(bytes(name)),\n            getChainId(),\n            address(this)\n         )\n      );\n      bytes32 structHash = keccak256(\n         abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            rawAmount,\n            nonces[owner]++,\n            deadline\n         )\n      );\n      bytes32 digest = keccak256(\n         abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n      );\n      address signatory = ecrecover(digest, v, r, s);\n      require(signatory != address(0), \"Ctx::permit: invalid signature\");\n      require(signatory == owner, \"Ctx::permit: unauthorized\");\n      require(block.timestamp <= deadline, \"Ctx::permit: signature expired\");\n\n      allowances[owner][spender] = amount;\n\n      emit Approval(owner, spender, amount);\n   }\n\n   /**\n    * @notice Get the number of tokens held by the `account`\n    * @param account The address of the account to get the balance of\n    * @return The number of tokens held\n    */\n   function balanceOf(address account) external view returns (uint256) {\n      return balances[account];\n   }\n\n   /**\n    * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    * @param dst The address of the destination account\n    * @param rawAmount The number of tokens to transfer\n    * @return Whether or not the transfer succeeded\n    */\n   function transfer(address dst, uint256 rawAmount) external returns (bool) {\n      uint96 amount = safe96(\n         rawAmount,\n         \"Ctx::transfer: amount exceeds 96 bits\"\n      );\n      _transferTokens(msg.sender, dst, amount);\n      return true;\n   }\n\n   /**\n    * @notice Transfer `amount` tokens from `src` to `dst`\n    * @param src The address of the source account\n    * @param dst The address of the destination account\n    * @param rawAmount The number of tokens to transfer\n    * @return Whether or not the transfer succeeded\n    */\n   function transferFrom(\n      address src,\n      address dst,\n      uint256 rawAmount\n   ) external returns (bool) {\n      address spender = msg.sender;\n      uint96 spenderAllowance = allowances[src][spender];\n      uint96 amount = safe96(rawAmount, \"Ctx::approve: amount exceeds 96 bits\");\n\n      if (spender != src && spenderAllowance != type(uint96).max) {\n         uint96 newAllowance = sub96(\n            spenderAllowance,\n            amount,\n            \"Ctx::transferFrom: transfer amount exceeds spender allowance\"\n         );\n         allowances[src][spender] = newAllowance;\n\n         emit Approval(src, spender, newAllowance);\n      }\n\n      _transferTokens(src, dst, amount);\n      return true;\n   }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n   function delegate(address delegatee) public {\n      return _delegate(msg.sender, delegatee);\n   }\n\n   /**\n    * @notice Delegates votes from signatory to `delegatee`\n    * @param delegatee The address to delegate votes to\n    * @param nonce The contract state required to match the signature\n    * @param expiry The time at which to expire the signature\n    * @param v The recovery byte of the signature\n    * @param r Half of the ECDSA signature pair\n    * @param s Half of the ECDSA signature pair\n    */\n   function delegateBySig(\n      address delegatee,\n      uint256 nonce,\n      uint256 expiry,\n      uint8 v,\n      bytes32 r,\n      bytes32 s\n   ) public {\n      bytes32 domainSeparator = keccak256(\n         abi.encode(\n            DOMAIN_TYPEHASH,\n            keccak256(bytes(name)),\n            getChainId(),\n            address(this)\n         )\n      );\n      bytes32 structHash = keccak256(\n         abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n      );\n      bytes32 digest = keccak256(\n         abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n      );\n      address signatory = ecrecover(digest, v, r, s);\n      require(signatory != address(0), \"Ctx::delegateBySig: invalid signature\");\n      require(\n         nonce == nonces[signatory]++,\n         \"Ctx::delegateBySig: invalid nonce\"\n      );\n      require(\n         block.timestamp <= expiry,\n         \"Ctx::delegateBySig: signature expired\"\n      );\n      return _delegate(signatory, delegatee);\n   }\n\n   /**\n    * @notice Gets the current votes balance for `account`\n    * @param account The address to get votes balance\n    * @return The number of current votes for `account`\n    */\n   function getCurrentVotes(address account) external view returns (uint96) {\n      uint32 nCheckpoints = numCheckpoints[account];\n      return\n         nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n   }\n\n   /**\n    * @notice Determine the prior number of votes for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param blockNumber The block number to get the vote balance at\n    * @return The number of votes the account had as of the given block\n    */\n   function getPriorVotes(address account, uint256 blockNumber)\n      public\n      view\n      returns (uint96)\n   {\n      require(\n         blockNumber < block.number,\n         \"Ctx::getPriorVotes: not yet determined\"\n      );\n\n      uint32 nCheckpoints = numCheckpoints[account];\n      if (nCheckpoints == 0) {\n         return 0;\n      }\n\n      // First check most recent balance\n      if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n         return checkpoints[account][nCheckpoints - 1].votes;\n      }\n\n      // Next check implicit zero balance\n      if (checkpoints[account][0].fromBlock > blockNumber) {\n         return 0;\n      }\n\n      uint32 lower = 0;\n      uint32 upper = nCheckpoints - 1;\n      while (upper > lower) {\n         uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n         Checkpoint memory cp = checkpoints[account][center];\n         if (cp.fromBlock == blockNumber) {\n            return cp.votes;\n         } else if (cp.fromBlock < blockNumber) {\n            lower = center;\n         } else {\n            upper = center - 1;\n         }\n      }\n      return checkpoints[account][lower].votes;\n   }\n\n   function _delegate(address delegator, address delegatee) internal {\n      address currentDelegate = delegates[delegator];\n      uint96 delegatorBalance = balances[delegator];\n      delegates[delegator] = delegatee;\n\n      emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n      _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n   }\n\n   function _transferTokens(\n      address src,\n      address dst,\n      uint96 amount\n   ) internal {\n      require(\n         src != address(0),\n         \"Ctx::_transferTokens: cannot transfer from the zero address\"\n      );\n      require(\n         dst != address(0),\n         \"Ctx::_transferTokens: cannot transfer to the zero address\"\n      );\n      require(\n         dst != address(this),\n         \"Ctx::_transferTokens: cannot transfer to the Ctx address\"\n      );\n\n      balances[src] = sub96(\n         balances[src],\n         amount,\n         \"Ctx::_transferTokens: transfer amount exceeds balance\"\n      );\n      balances[dst] = add96(\n         balances[dst],\n         amount,\n         \"Ctx::_transferTokens: transfer amount overflows\"\n      );\n      emit Transfer(src, dst, amount);\n\n      _moveDelegates(delegates[src], delegates[dst], amount);\n   }\n\n   function _moveDelegates(\n      address srcRep,\n      address dstRep,\n      uint96 amount\n   ) internal {\n      if (srcRep != dstRep && amount > 0) {\n         if (srcRep != address(0)) {\n            uint32 srcRepNum = numCheckpoints[srcRep];\n            uint96 srcRepOld = srcRepNum > 0\n               ? checkpoints[srcRep][srcRepNum - 1].votes\n               : 0;\n            uint96 srcRepNew = sub96(\n               srcRepOld,\n               amount,\n               \"Ctx::_moveVotes: vote amount underflows\"\n            );\n            _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n         }\n\n         if (dstRep != address(0)) {\n            uint32 dstRepNum = numCheckpoints[dstRep];\n            uint96 dstRepOld = dstRepNum > 0\n               ? checkpoints[dstRep][dstRepNum - 1].votes\n               : 0;\n            uint96 dstRepNew = add96(\n               dstRepOld,\n               amount,\n               \"Ctx::_moveVotes: vote amount overflows\"\n            );\n            _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n         }\n      }\n   }\n\n   function _writeCheckpoint(\n      address delegatee,\n      uint32 nCheckpoints,\n      uint96 oldVotes,\n      uint96 newVotes\n   ) internal {\n      uint32 blockNumber = safe32(\n         block.number,\n         \"Ctx::_writeCheckpoint: block number exceeds 32 bits\"\n      );\n\n      if (\n         nCheckpoints > 0 &&\n         checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n      ) {\n         checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      } else {\n         checkpoints[delegatee][nCheckpoints] = Checkpoint(\n            blockNumber,\n            newVotes\n         );\n         numCheckpoints[delegatee] = nCheckpoints + 1;\n      }\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n   }\n\n   function safe32(uint256 n, string memory errorMessage)\n      internal\n      pure\n      returns (uint32)\n   {\n      require(n < 2**32, errorMessage);\n      return uint32(n);\n   }\n\n   function safe96(uint256 n, string memory errorMessage)\n      internal\n      pure\n      returns (uint96)\n   {\n      require(n < 2**96, errorMessage);\n      return uint96(n);\n   }\n\n   function add96(\n      uint96 a,\n      uint96 b,\n      string memory errorMessage\n   ) internal pure returns (uint96) {\n      uint96 c = a + b;\n      require(c >= a, errorMessage);\n      return c;\n   }\n\n   function sub96(\n      uint96 a,\n      uint96 b,\n      string memory errorMessage\n   ) internal pure returns (uint96) {\n      require(b <= a, errorMessage);\n      return a - b;\n   }\n\n   function getChainId() internal view returns (uint256) {\n      uint256 chainId;\n      assembly {\n         chainId := chainid()\n      }\n      return chainId;\n   }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/tests/Delegator.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../lib/ds-test/src/test.sol\";\n\nimport \"../Delegator.sol\";\nimport \"../mocks/GovernanceToken.sol\";\n\ncontract User {\n   function doStake(Delegator d, uint256 amount) public {\n      d.stake(address(this), amount);\n   }\n\n   function doRemoveStake(Delegator d, uint256 amount) public {\n      d.removeStake(address(this), amount);\n   }\n}\n\ncontract FakeToken {\n   function decimals() public pure returns (uint8) {\n      return 10;\n   }\n}\n\ncontract DelegatorTest is DSTest {\n   address delegatee = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045;\n   Delegator delegator;\n   GovernanceToken ctx;\n   User user1;\n\n   function setUp() public {\n      ctx = new GovernanceToken(address(this), address(this), block.timestamp);\n      delegator = new Delegator(delegatee, address(ctx));\n      user1 = new User();\n   }\n\n   function test_parameters() public {\n      assertEq(delegator.owner(), address(this));\n      assertEq(delegator.delegatee(), delegatee);\n      assertEq(delegator.token(), address(ctx));\n      assertEq(ctx.delegates(address(delegator)), delegatee);\n   }\n\n   function testFail_invalidDelegatee() public {\n      new Delegator(address(0x0), address(ctx));\n   }\n\n   function testFail_invalidToken() public {\n      new Delegator(delegatee, address(0x0));\n   }\n\n   function testFail_invalidTokenDecimals() public {\n      FakeToken f = new FakeToken();\n      new Delegator(delegatee, address(f));\n   }\n\n   function test_stake(address staker, uint256 amount) public {\n      if (amount >= ctx.totalSupply()) return;\n      if (staker == address(0)) return;\n      assertEq(delegator.stakerBalance((staker)), 0);\n      delegator.stake(staker, amount);\n      assertEq(delegator.stakerBalance((staker)), amount);\n      ctx.transfer(address(delegator), amount); //simulate transfer from owner\n      assertEq(ctx.getCurrentVotes(delegatee), amount);\n      assertEq(ctx.balanceOf(address(delegator)), amount);\n   }\n\n   function testFail_stake_notOwner(uint256 amount) public {\n      user1.doStake(delegator, amount);\n   }\n\n   function test_removeStake() public {\n      address staker = address(0x1);\n      uint256 amount = 1 ether;\n      ctx.transfer(address(delegator), amount); //simulate transfer from owner\n      delegator.stake(staker, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), amount);\n      assertEq(delegator.stakerBalance((staker)), amount);\n      assertEq(ctx.balanceOf(address(delegator)), amount);\n      delegator.removeStake(staker, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), 0);\n      assertEq(delegator.stakerBalance((staker)), 0);\n      assertEq(ctx.balanceOf(address(delegator)), 0);\n      assertEq(ctx.balanceOf(staker), amount);\n   }\n\n   function test_removeStakeFuzz(address staker, uint256 amount) public {\n      if (amount >= ctx.totalSupply()) return;\n      if (staker == address(0)) return;\n      ctx.transfer(address(delegator), amount); //simulate transfer from owner\n      delegator.stake(staker, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), amount);\n      assertEq(delegator.stakerBalance((staker)), amount);\n      assertEq(ctx.balanceOf(address(delegator)), amount);\n      delegator.removeStake(staker, amount);\n      assertEq(ctx.getCurrentVotes(delegatee), 0);\n      assertEq(delegator.stakerBalance((staker)), 0);\n      assertEq(ctx.balanceOf(address(delegator)), 0);\n      assertEq(ctx.balanceOf(staker), amount);\n   }\n\n   function testFail_removeStake_notOwner(uint256 amount) public {\n      ctx.transfer(address(delegator), amount); //simulate transfer from owner\n      delegator.stake(address(user1), amount);\n      user1.doRemoveStake(delegator, amount);\n   }\n\n   function testFail_removeStake_notEnoughBalance(uint256 amount) public {\n      ctx.transfer(address(delegator), amount); //simulate transfer from owner\n      delegator.stake(address(user1), amount);\n      delegator.removeStake(address(user1), amount + 1);\n   }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}